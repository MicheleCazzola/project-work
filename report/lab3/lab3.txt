To: Maria Luigia Brizzi
Your solution is very clean and clear to understand, with proper comments, variable names and concise documentation provided.
Summarizing what you have done:
- the initialization is very simple and clear, it seems a good alternative to the one proposed in the laboratory, that is going
back from the goal state doing a given number of actions
- the search algorithm is a standard A*, which uses an admissible heuristic (sum of Manhattan distances of each tile to the
correct position in the grid), guaranteeing to find the least cost solution, and it is correctly implemented using a priority
queue to represent the frontier (open set), and a set of already visited states to avoid loops

In general, this solution is correct and clearly presented. However, here are few notes about it:
- there are no comparisons among different problem sizes, since it is fixed to 4.
- there are no comparisons among different solving streategies: an alternative is greedy best-first, which could be interesting
to analyze since it is known to be faster but less accurate in finding the least cost solution. Thus, it could converge on larger
instances, wheres A* cannot, if we suppose to keep the heuristic fixed (using a non-admissible heuristic could be an alternative,
but requires more analysis and tweaking).
- it might be useful (in particular for the reviewer) to report your results somewhere, in order to compare how the proposed
solution behaves (in terms of quality and cost) with respect to the problem size.
- it might be useful to run the algorithm on many instances, for each problem size, in order to average the results on several
trials and to obtain a better view of the performances: there are limits due to the computational cost of such method, but it
may be still feasible for small instances (N < 5) and some trials (T = 10).


To: Fabio Gigante
Your solution is well-written and clear, with good documentation, comments and variable names.
Results are reported clearly, grouped per instance, problem size and heuristic used, in terms of both quality and cost.

In particular:
- the comparison among different heuristics is very interesting: they are all admissible, but considering a non-consistent moves
the focus towards a trade-off solution, where worse quality is accepted, but at lower cost (and convergence time, specially).
- providing Dijkstra solution is helpful to verify whether A* is working correctly and how much is the chosen heuristic effective.

Few notes:
- it may be interesting to extend the solution to non-admissible heuristics: the algorithm will be speeded up, even if probably
finding a worse solution than using an admissible, not consistent heuristic.
- you can extend your solution to bigger problems: using non-admissible heuristics could be highly beneficial here, allowing the
algorithm to converge in a reasonable amount of time. The quality of the final solution will be lower than what you would achieve
using an admissible (or even consistent) heuristic; however, due to the computational cost of the latter, it's preferable to obtain
a decent result rather than none at all.
- it might be useful to run the algorithm on many instances, for each problem size, in order to average the results on several trials
and to obtain a better view of the performances: there are limits due to the computational cost of such method, but it may be still
feasible for small instances (N < 5) and some trials (T = 10). It is clear that you would need to adjust your heuristic (not only the
function, but also its parameters) for each problem size, to focus more either on quality or cost (that is, convergence time).